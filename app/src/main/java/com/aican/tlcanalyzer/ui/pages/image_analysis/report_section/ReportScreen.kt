package com.aican.tlcanalyzer.ui.pages.image_analysis.report_section


import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.net.Uri
import android.os.Environment
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.View
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.unit.dp
import com.aican.tlcanalyzer.data.database.project.entities.ContourData
import com.aican.tlcanalyzer.domain.states.image.ImageState
import com.aican.tlcanalyzer.ui.components.topbar_navigation.CustomTopBar
import com.aican.tlcanalyzer.ui.pages.image_analysis.components.*
import com.aican.tlcanalyzer.utils.AppUtils
import com.aican.tlcanalyzer.viewmodel.project.*
import com.itextpdf.io.image.ImageDataFactory
import com.itextpdf.kernel.colors.DeviceGray
import com.itextpdf.kernel.colors.DeviceRgb
import com.itextpdf.kernel.pdf.*
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.*
import kotlinx.coroutines.*
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileOutputStream
import java.io.OutputStream
import java.text.SimpleDateFormat
import java.util.*


@Composable
fun ReportScreen(
    imageAnalysisViewModel: ImageAnalysisViewModel,
    intensityChartViewModel: IntensityChartViewModel,
    projectViewModel: ProjectViewModel,
    projectId: String
) {
    val contourDataList by imageAnalysisViewModel.allAutoGeneratedSpotsData.collectAsState()
    val intensityDataState by imageAnalysisViewModel.intensityDataState.collectAsState()
    val lineChartData by intensityChartViewModel.lineChartDataList.collectAsState()
    val numberOfIntensityParts by projectViewModel.cachedIntensityParts.collectAsState()
    val imageDetail by projectViewModel.selectedImageDetail.collectAsState()
    val project by projectViewModel.observerProjectDetails(projectId).collectAsState(initial = null)

    val contourImageState = remember { mutableStateOf(ImageState()) }
    val originalImageState = remember { mutableStateOf(ImageState()) }
    var isLoading by remember { mutableStateOf(false) }
    var pdfUri by remember { mutableStateOf<Uri?>(null) }

    val view = LocalView.current

    val context = LocalContext.current

    var intensityChartBitmap = remember { mutableStateOf<Bitmap?>(null) }
    val volumeChartBitmap = remember { mutableStateOf<Bitmap?>(null) }

    LaunchedEffect(imageDetail) {
        imageDetail?.let {
            contourImageState.value = contourImageState.value.copy(
                imagePath = it.contourImagePath ?: "",
                description = "Updated Image",
                changeTrigger = !contourImageState.value.changeTrigger
            )
            originalImageState.value = originalImageState.value.copy(
                imagePath = it.croppedImagePath ?: "",
                description = "Updated Image",
                changeTrigger = !originalImageState.value.changeTrigger
            )
        }
    }

    val options = listOf(
        "Original image",
        "Detected contours image",
        "Contour's detailed table",
        "Intensity Plot",
        "Volume Plot"
    )
    val selectedOptions = remember { mutableStateListOf<String>() }

    Scaffold(
        topBar = {
            CustomTopBar(
                title = "Generate Report",
                showBackButton = true,
                onBackClick = { /* Handle back navigation */ }
            )
        }
    ) { internalPadding ->
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(internalPadding)
                    .padding(16.dp)
            ) {
                item {
                    Text(
                        text = "Get reports of",
                        style = MaterialTheme.typography.headlineSmall,
                        modifier = Modifier.padding(vertical = 16.dp)
                    )

                    options.forEach { option ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 2.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = selectedOptions.contains(option),
                                onCheckedChange = { isChecked ->
                                    if (isChecked) {
                                        selectedOptions.add(option)
                                    } else {
                                        selectedOptions.remove(option)
                                    }
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(text = option, style = MaterialTheme.typography.bodyLarge)
                        }
                    }

                    Button(
                        onClick = {
                            CoroutineScope(Dispatchers.IO).launch {
                                try {
                                    isLoading = true
                                    pdfUri = generatePDF(
                                        context = context,
                                        originalImageState = originalImageState.value,
                                        contourImageState = contourImageState.value,
                                        selectedOptions = selectedOptions,
                                        intensityChartBitmap = intensityChartBitmap.value,
                                        volumeChartBitmap = volumeChartBitmap.value,
                                        contourDataList = contourDataList,
                                        numberOfIntensityParts = numberOfIntensityParts ?: 100,
                                        projectName = project?.projectName ?: "Unknown"
                                    )
                                } catch (e: Exception) {
                                    e.printStackTrace() // Log the error
                                } finally {
                                    isLoading = false // Ensure loading state is reset
                                }
                            }
                        },
                        enabled = selectedOptions.isNotEmpty() &&
                                (("Intensity Plot" in selectedOptions && intensityChartBitmap.value != null) || "Intensity Plot" !in selectedOptions) &&
                                (("Volume Plot" in selectedOptions && volumeChartBitmap.value != null) || "Volume Plot" !in selectedOptions),
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 16.dp)
                    ) {
                        Text(text = "Generate Report")
                    }


                }

                item {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .alpha(0f) // Invisible to the user
                    ) {
                        IntensityDataSection(
                            parts = numberOfIntensityParts ?: 100,
                            intensityDataState = intensityDataState,
                            lineChartData = lineChartData,
                            contourDataList = contourDataList
                        ) { chartBitmap ->
                            intensityChartBitmap.value = chartBitmap
                        }

                        BarGraph(contourDataList = contourDataList) { chartBitmap ->
                            volumeChartBitmap.value = chartBitmap
                        }

                        ImageSection(imageState = originalImageState.value, zoomable = false)
                        ImageSection(imageState = contourImageState.value, zoomable = false)
                        TableScreen(contourDataList)

                    }

                }

//                if (selectedOptions.contains("Original image")) {
//                item {
//                    ImageSection(imageState = originalImageState.value, zoomable = false)
//                }
//                }

//                if (selectedOptions.contains("Detected contours image")) {
//                item {
//                    ImageSection(imageState = contourImageState.value, zoomable = false)
//                }
//                }

//                if (selectedOptions.contains("Intensity Plot")) {
//                item {
//                    IntensityDataSection(
//                        parts = numberOfIntensityParts ?: 100,
//                        intensityDataState = intensityDataState,
//                        lineChartData = lineChartData,
//                        contourDataList = contourDataList
//                    ) { chartBitmap ->
//                        intensityChartBitmap.value = chartBitmap
//                    }
//                }
//                }

//                if (selectedOptions.contains("Volume Plot")) {
//                item {
//                    BarGraph(contourDataList = contourDataList) { chartBitmap ->
//                        volumeChartBitmap.value = chartBitmap
//                    }
//                }
//                }


//                if (selectedOptions.contains("Contour's detailed table")) {
//                item {
//                    TableScreen(contourDataList)
//                }
//                }
            }
        }
    }
}

suspend fun generatePDF(
    context: Context,
    originalImageState: ImageState?,
    contourImageState: ImageState?,
    selectedOptions: List<String>,
//    originalImage: Bitmap?,
//    contourImage: Bitmap?,
    intensityChartBitmap: Bitmap?,
    volumeChartBitmap: Bitmap?,
    contourDataList: List<ContourData>,
    numberOfIntensityParts: Int,
    projectName: String
): Uri? {
    return withContext(Dispatchers.IO) {
        delay(1000)
        try {
            val sdf = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss", Locale.getDefault())
            val fileName = "Report_${projectName}_${sdf.format(Date())}.pdf"

            val file = File(
                context.getExternalFilesDir(null)
                    .toString() + File.separator + "All PDF Files/${fileName}"
            )
//            val file = File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), fileName)

            val outputStream: OutputStream = FileOutputStream(file)
            val writer = PdfWriter(file)
            val pdfDocument = PdfDocument(writer)
            val document = Document(pdfDocument)

            // Title
            document.add(
                Paragraph("TLC Analyzer Report").setFontSize(24f).setFontColor(DeviceRgb(0, 0, 255))
            )
            document.add(
                Paragraph("Generated on: ${sdf.format(Date())}").setFontSize(14f)
                    .setFontColor(DeviceGray.GRAY)
            )
            document.add(Paragraph("\n"))

            // Add Images based on Selection
            fun addImage(bitmap: Bitmap?, title: String) {
                if (bitmap == null) {
                    Log.e("BitmapNull", "Bitmap is null")
                }
                bitmap?.let {
                    document.add(
                        Paragraph(title).setFontSize(18f).setFontColor(DeviceRgb(255, 0, 0))
                    )
                    val stream = ByteArrayOutputStream()
                    it.compress(Bitmap.CompressFormat.JPEG, 100, stream)
                    val imageData = ImageDataFactory.create(stream.toByteArray())
                    val image = Image(imageData).scaleToFit(500f, 350f)
                    document.add(image)
                    document.add(Paragraph("\n"))
                }
            }

            if (selectedOptions.contains("Original image")) {
                val filePath = originalImageState?.imagePath
                if (filePath != null && filePath.isNotEmpty()) {
                    val imageFile = File(filePath)

                    val bitmap = BitmapFactory.decodeFile(imageFile.path)
                    addImage(bitmap, "Original Image")
                }
            }
            if (selectedOptions.contains("Detected contours image")) {
                val filePath = contourImageState?.imagePath
                if (filePath != null && filePath.isNotEmpty()) {
                    val imageFile = File(filePath)

                    val bitmap = BitmapFactory.decodeFile(imageFile.path)
                    addImage(bitmap, "Contour Image")
                }
            }

            if (selectedOptions.contains("Contour's detailed table")) {
                document.add(
                    Paragraph("Contour's detailed table").setFontSize(18f)
                        .setFontColor(DeviceRgb(255, 0, 0))
                )
                val columnWidth = floatArrayOf(200f, 210f, 190f, 170f, 170f, 240f, 340f)

                val table = Table(columnWidth)
                table.addCell("Id")
                table.addCell("Rf")
                table.addCell("Cv")
                table.addCell("Area")
                table.addCell("% Area")
                table.addCell("Volume")
                table.addCell("Label")

                var totalArea = 0f

                for (i in contourDataList.indices) {
                    totalArea += contourDataList[i].area.toFloat()
                }

                for (i in contourDataList.indices) {
                    val contourData = contourDataList[i]
                    table.addCell(contourData.name)
                    table.addCell(AppUtils.formatToTwoDecimalPlaces(contourData.rf))
                    table.addCell(AppUtils.formatToTwoDecimalPlaces(contourData.cv))
                    table.addCell(AppUtils.formatToTwoDecimalPlaces(contourData.area))
                    table.addCell(
                        String.format(
                            "%.2f",
                            (contourData.area.toFloat() / totalArea) * 100
                        ) + " %"
                    )
                    table.addCell(contourData.volume)
                    table.addCell(
                        contourData.chemicalName
                    )
                }

                document.add(table)

            }

            if (selectedOptions.contains("Intensity Plot")) addImage(
                intensityChartBitmap,
                "Intensity Plot"
            )
            if (selectedOptions.contains("Volume Plot")) addImage(volumeChartBitmap, "Volume Plot")

            document.close()
            outputStream.close()
            return@withContext Uri.fromFile(file)

        } catch (e: Exception) {
            Log.e("PDF_ERROR", "Error generating PDF: ${e.message}")
            return@withContext null
        }
    }
}

suspend fun captureComposableAsBitmap(context: Context, content: @Composable () -> Unit): Bitmap {
    return withContext(Dispatchers.Main) {

        val composeView = ComposeView(context)

        val handler = Handler(Looper.getMainLooper())
        val bitmap = Bitmap.createBitmap(1000, 800, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)

        val deferredBitmap = CompletableDeferred<Bitmap>()

        handler.post {
            composeView.setContent { content() }

            composeView.measure(
                View.MeasureSpec.makeMeasureSpec(1000, View.MeasureSpec.EXACTLY),
                View.MeasureSpec.makeMeasureSpec(800, View.MeasureSpec.EXACTLY)
            )
            composeView.layout(0, 0, composeView.measuredWidth, composeView.measuredHeight)
            composeView.draw(canvas)

            deferredBitmap.complete(bitmap)
        }

        return@withContext deferredBitmap.await()
    }
}

